# Detailed Notes – Snowflake File Formats & `COPY INTO` Usage

## 1. Specifying File Format Directly in `COPY INTO` Command
```sql
COPY INTO OUR_FIRST_DB.PUBLIC.ORDERS_EX
    FROM @MANAGE_DB.external_stages.aws_stage_errorex
    file_format = (type = csv field_delimiter=',' skip_header=1)
    files = ('OrderDetails_error.csv')
    ON_ERROR = 'SKIP_FILE_3';
```
**Explanation:**
- **Purpose**: Load data from an external stage into the target table.
- **Key points:**
  - `type = csv` → Specifies the file type.
  - `field_delimiter=','` → Columns are separated by commas.
  - `skip_header=1` → Skips the first line (header row).
  - `files = ('OrderDetails_error.csv')` → Loads only this specific file.
  - `ON_ERROR = 'SKIP_FILE_3'` → If 3 or more rows in the file have errors, **skip the entire file**; otherwise load the rest.

**When to use:**  
When loading files directly without creating a reusable **file format object**.

---

## 2. Creating the Target Table
```sql
CREATE OR REPLACE TABLE OUR_FIRST_DB.PUBLIC.ORDERS_EX (
    ORDER_ID VARCHAR(30),
    AMOUNT INT,
    PROFIT INT,
    QUANTITY INT,
    CATEGORY VARCHAR(30),
    SUBCATEGORY VARCHAR(30)
);
```
**Explanation:**
- Defines the **schema** for data loading.
- Matches column names and datatypes with the source CSV file for smooth loading.

---

## 3. Creating a Schema for File Formats
```sql
CREATE OR REPLACE SCHEMA MANAGE_DB.file_formats;
```
**Explanation:**
- **Purpose**: Keep all file format objects in one place for better organization.
- **Real-world tip**:  
  Create separate schemas like `file_formats`, `stages`, `pipes` to keep Snowflake objects structured.

---

## 4. Creating a File Format Object
```sql
CREATE OR REPLACE file format MANAGE_DB.file_formats.my_file_format;
```
**Explanation:**
- Creates a reusable file format object with **default settings** (default type is CSV).
- Benefits:
  - No need to repeat file format parameters in every `COPY INTO` statement.
  - Centralized change management.

---

## 5. Viewing File Format Properties
```sql
DESC file format MANAGE_DB.file_formats.my_file_format;
```
**Explanation:**
- Displays the configuration of the file format object (e.g., type, delimiters, null handling).

---

## 6. Using File Format Object in `COPY INTO`
```sql
COPY INTO OUR_FIRST_DB.PUBLIC.ORDERS_EX
    FROM @MANAGE_DB.external_stages.aws_stage_errorex
    file_format= (FORMAT_NAME=MANAGE_DB.file_formats.my_file_format)
    files = ('OrderDetails_error.csv')
    ON_ERROR = 'SKIP_FILE_3';
```
**Explanation:**
- Instead of redefining `type, field_delimiter, skip_header`, the `FORMAT_NAME` references the reusable file format.

---

## 7. Altering File Format Properties
```sql
ALTER file format MANAGE_DB.file_formats.my_file_format
    SET SKIP_HEADER = 1;
```
**Explanation:**
- Modifies the existing file format to skip 1 header row.
- **Note**: You **cannot** change the `TYPE` of a file format using `ALTER`.  
  To change the type, you must recreate the file format.

---

## 8. Creating File Format with Specific Properties
```sql
CREATE OR REPLACE file format MANAGE_DB.file_formats.my_file_format
    TYPE=JSON,
    TIME_FORMAT=AUTO;
```
**Explanation:**
- Example: Defines a JSON file format with automatic time parsing.
- Real-world use: For loading nested JSON data into VARIANT columns.

---

## 9. Altering File Format Type is Not Possible
```sql
ALTER file format MANAGE_DB.file_formats.my_file_format
SET TYPE = CSV;
```
**Explanation:**
- Snowflake **does not allow** changing the file type from JSON to CSV (or vice versa) via `ALTER`.
- **Solution**: Use `CREATE OR REPLACE` to recreate it.

---

## 10. Recreating File Format
```sql
CREATE OR REPLACE file format MANAGE_DB.file_formats.my_file_format;
```
**Explanation:**
- Recreates the file format with default (CSV) type.
- Resets all previous configurations unless explicitly specified.

---

## 11. Truncating the Table
```sql
TRUNCATE table OUR_FIRST_DB.PUBLIC.ORDERS_EX;
```
**Explanation:**
- Removes all rows from the table without dropping its structure.
- Useful before reloading data.

---

## 12. Overwriting File Format Properties in `COPY INTO`
```sql
COPY INTO OUR_FIRST_DB.PUBLIC.ORDERS_EX
    FROM  @MANAGE_DB.external_stages.aws_stage_errorex
    file_format = (FORMAT_NAME= MANAGE_DB.file_formats.my_file_format  field_delimiter = ',' skip_header=1 )
    files = ('OrderDetails_error.csv')
    ON_ERROR = 'SKIP_FILE_3';
```
**Explanation:**
- Even when using a `FORMAT_NAME`, you can **override** certain properties like `field_delimiter` or `skip_header` just for that load.

---

## 13. Describing a Stage
```sql
DESC STAGE MANAGE_DB.external_stages.aws_stage_errorex;
```
**Explanation:**
- Displays details of the external stage such as:
  - Location (S3, Azure Blob, GCS)
  - File format association (if any)
  - Stage parameters

---

## Key Concept: `ON_ERROR = 'SKIP_FILE_n'`
- **`n` = Threshold of bad rows before skipping the file entirely.**
- Example:
  - `SKIP_FILE_3` → If **3 or more errors**, skip entire file; otherwise skip only bad rows.
- Ensures a **balance between data quality and load success**.

---

## Real-World Best Practices
1. **Use file format objects** for consistency across multiple loads.
2. **Organize schemas** (`file_formats`, `stages`, `pipes`) to avoid clutter.
3. **Always `DESC` file formats** and stages before loading to confirm settings.
4. **Test with small files** before loading large datasets.
5. **Truncate carefully** — it’s irreversible unless you have Time Travel enabled.
