
# Explanation — `COPY INTO` with Stage and Positional Columns

```sql
COPY INTO OUR_FIRST_DB.PUBLIC.ORDERS_EX
    FROM (SELECT s.$1, s.$2 FROM @MANAGE_DB.external_stages.aws_stage s)
    FILE_FORMAT = (TYPE = CSV FIELD_DELIMITER=',' SKIP_HEADER=1)
    FILES = ('OrderDetails.csv');
```

## What this does
- **Target table:** Loads data **into** `OUR_FIRST_DB.PUBLIC.ORDERS_EX`.
- **Source:** Reads from the **external stage** `@MANAGE_DB.external_stages.aws_stage`.
- **Projection:** `SELECT s.$1, s.$2` pulls the **1st and 2nd fields** from each CSV row (positional columns).
- **File parsing:** `FILE_FORMAT` says rows are **CSV**, **comma**-delimited, and the **first line is a header** (skipped).
- **Scope of files:** `FILES=('OrderDetails.csv')` restricts the load to that one file (relative to the stage URL).

## Key details
- **Stage alias `s`:** Just a table alias for the file stream in the stage.
- **Positional columns (`$1`, `$2`):** Refer to field positions in the parsed row. You can transform them in-line, e.g. `TO_NUMBER(s.$1)`, `TO_DATE(s.$2, 'YYYY-MM-DD')`, `TRIM(s.$2)`.
- **Target column mapping:** Because the `SELECT` outputs **two columns**, either:
  - The table `ORDERS_EX` must accept exactly **two columns** in that order, **or**
  - You should list **target columns** explicitly in `COPY INTO` (recommended).

## “Better” version with explicit target columns and casts
```sql
COPY INTO OUR_FIRST_DB.PUBLIC.ORDERS_EX (order_id, amount)
FROM (
  SELECT TO_NUMBER(s.$1)       AS order_id,
         TO_DECIMAL(s.$2,10,2) AS amount
  FROM @MANAGE_DB.external_stages.aws_stage s
)
FILE_FORMAT = (TYPE = CSV FIELD_DELIMITER=',' SKIP_HEADER=1)
FILES = ('OrderDetails.csv');
```

- **Why better?** Explicit target columns + **type casting** avoids implicit-cast surprises and column-order mistakes.

## Validation after load
```sql
-- Rows loaded in the last COPY (scan the previous result set)
SELECT SUM(TO_NUMBER(rows_loaded)) AS total_rows_loaded
FROM TABLE(RESULT_SCAN(LAST_QUERY_ID()));

-- Count in the target table
SELECT COUNT(*) FROM OUR_FIRST_DB.PUBLIC.ORDERS_EX;
```

## Common issues to watch
- **File not found:** Ensure `FILES` includes the correct **relative path** under the stage (case-sensitive if quoted).
- **Column count mismatch:** The number of columns produced by the `SELECT` must match the target list/table.
- **Rejected rows:** Usually delimiter/header mismatches or bad casts → adjust `FILE_FORMAT` or fix casts.
- **Permissions:** Ensure your role has `USAGE` on the stage’s DB/schema and **`INSERT`** on the target table.
